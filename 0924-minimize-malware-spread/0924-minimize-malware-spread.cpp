class Solution {
private:
    // Simulate infecting all nodes the infected nodes can reach
    void DFS(unordered_set<int>& infectedSet, const vector<vector<int>>& adjMatrix, const int& lastNode, const int& n){
        unordered_set<int> reachableNodes;
        for (auto i = 0; i < n; i++){
            if (adjMatrix[lastNode][i] == 1){
                reachableNodes.insert(i);
            }
        }

        reachableNodes.erase(lastNode);

        for (const auto& node: reachableNodes){
            if (infectedSet.contains(node)) continue;
            infectedSet.insert(node);
            DFS(infectedSet, adjMatrix, node, n);
        }
    }

public:
    int minMalwareSpread(const vector<vector<int>>& graph, const vector<int>& initial) {
        // For every node in initial
        int initialSize = initial.size();
        int n = graph.size();

        unordered_set<int> initialSet;
        for (const auto& index: initial){
            initialSet.insert(index);
        }

        unordered_set<int> infectedSet;
        int runningMin = n + 1;
        int minIndex = n + 1;

        for (auto initialIndex = 0; initialIndex < initialSize; initialIndex++){
            // Remove 1 node from initial
            int removedNode = initial[initialIndex];
            infectedSet = initialSet;
            infectedSet.erase(removedNode);

            // Simulate infecting all nodes the other infected nodes can
            for (const auto& infectedNode: infectedSet){
                DFS(infectedSet, graph, infectedNode, n);
            }
            
            // Store the number of infected nodes for removing that node
            int infected = infectedSet.size();

            if (runningMin > infected || (runningMin == infected && minIndex > removedNode)){
                runningMin = infected;
                minIndex = removedNode;
            }
        }

        return minIndex;
    }
};