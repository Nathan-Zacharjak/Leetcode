class Solution {
private:
    // Simulate infecting all nodes the infected nodes can reach
    void DFS(unordered_set<int>& infectedSet, const vector<vector<int>>& adjMatrix, const int& lastNode){
        unordered_set<int> reachableNodes;
        for (auto i = 0; i < adjMatrix.size(); i++){
            if (adjMatrix[lastNode][i] == 1){
                reachableNodes.insert(i);
            }
        }

        for (const auto& node: reachableNodes){
            if (infectedSet.contains(node)) continue;
            infectedSet.insert(node);
            DFS(infectedSet, adjMatrix, node);
        }
    }

public:
    int minMalwareSpread(const vector<vector<int>>& graph, const vector<int>& initial) {
        // When all of the nodes are connected, none of the nodes are connected, or only the infected nodes are connected, you remove the infected node with the smallest index
        // If there is a cut node, you remove that node
        // If there are multiple cut nodes, you remove the node with the greatest non-infected cut
        // If there are multiple cut nodes with the same non-infected cut size, you remove an infected cut node over a non-infected one
        // If the greatest cut size is the same, and they are both infected/not infected, then just remove the node with the smallest index

        // First, find all of the back-edges of the graph
        // DFS down a random start node, and store the current path in a set
        // If a found node is part of the path, and not the last node just visited, mark this edge as a back edge
        // Store the current path, starting from the node at the end of the back edge, to the current node, as a "reachable group"
        // Mark the end of the back-edge as a cut node

        // For every node in initial
        int initialSize = initial.size();
        int n = graph.size();
        unordered_set<int> initialSet;
        for (const auto& index: initial){
            initialSet.insert(index);
        }

        vector<int> infectedCount(initialSize, n + 1);

        for (auto initialIndex = 0; initialIndex < initialSize; initialIndex++){
            // Remove 1 node from initial
            int removedNode = initial[initialIndex];
            // auto newGraph = graph;
            // for (auto i = 0; i < n; i++){
            //     for (auto j = 0; j < n; j++){
            //         if (i == removedNode || j == removedNode){
            //             newGraph[i][j] = 0;
            //         }
            //     }
            // }
            unordered_set<int> infectedSet = initialSet;
            infectedSet.erase(removedNode);

            // Simulate infecting all nodes the other infected nodes can
            for (const auto& infectedNode: infectedSet){
                DFS(infectedSet, graph, infectedNode);
            }
            
            // Store the number of infected nodes for removing that node
            infectedCount[initialIndex] = infectedSet.size();
        }

        // After, do a running min of number of infected nodes for each removed infected node, from the smallest to the largest index
        int runningMin = n + 1;
        int minIndex = n + 1;
        
        for (auto i = 0; i < initialSize; i++){
            int index = initial[i];
            int infected = infectedCount[i];

            if (runningMin > infected || (runningMin == infected && minIndex > index)){
                runningMin = infected;
                minIndex = index;
            }
        }

        return minIndex;
    }
};