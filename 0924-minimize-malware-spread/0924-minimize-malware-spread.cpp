#include <print>

class DSU {
private:
    vector<int> parent;
    vector<int> rank;
    vector<int> size;

public:
    DSU(const int& n){
        parent = vector<int>(n);
        for (auto i = 0; i < n; i++) parent[i] = i;
        rank = vector<int>(n, 1);
        size = vector<int>(n, 1);
    }

    void Union(const int& i1, const int& i2){
        int c1 = Find(i1);
        int c2 = Find(i2);

        println("i1: {}, i2: {}, c1: {}, c2: {}", i1, i2, c1, c2);

        if (c1 == c2){
            return;
        } else if (rank[c1] < rank[c2]){
            parent[c1] = c2;
            size[c2] += size[c1];
        } else if (rank[c1] > rank[c2]){
            parent[c2] = c1;
            size[c1] += size[c2];
        } else {
            parent[c2] = c1;
            size[c1] += size[c2];
            rank[c1]++;
        }
    }

    int Find(const int& i){
        if (i == parent[i]) return i;
        // parent[parent[i]] = parent[i];
        parent[i] = parent[parent[i]];
        return Find(parent[i]);
    }

    int Size(const int& c){
        return size[c];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        if (initial.empty()) return 0;

        // Find all connected components (DSU)
        int n = graph.size();
        DSU disjointSets(n);
        for (auto i = 0; i < n; i++){
            for (auto j = 0; j < n; j++){
                if (graph[i][j] == 1 && i != j){
                    disjointSets.Union(i, j);
                }
            }
        }

        println("Components:");
        for (auto i = 0; i < n; i++){
            println("i: {}, component: {}", i, disjointSets.Find(i));
        }

        println("Component sizes:");
        for (auto i = 0; i < n; i++){
            println("i: {}, size: {}", i, disjointSets.Size(disjointSets.Find(i)));
        }

        // Find largest connected component with 1 infected node       
        unordered_map<int, int> componentCount;

        for (const auto& node: initial){
            int component = disjointSets.Find(node);
            componentCount[component]++;
        }

        println("Component count:");
        for (const auto& [component, count]: componentCount){
            println("component: {}, count: {}", component, count);
        }

        // If all components have multiple infected nodes, return the smallest index (0)
        int result = -1;
        int maxSize = 0;

        sort(initial.begin(), initial.end());

        for (const auto& node: initial){
            println("node: {}, maxSize: {}, result: {}", node, maxSize, result);
            int component = disjointSets.Find(node);
            int size = disjointSets.Size(component);

            // If there is a tie in component size, return the infected node with the smallest index
            if (componentCount[component] == 1 && size > maxSize){
                result = node;
                maxSize = size;
            }
            println("node: {}, size: {}, component: {}, maxSize: {}, result: {}", node, size, component, maxSize, result);
        }

        return maxSize != 0 ? result : initial[0];
    }
};